#include <windows.h>
#include <string>

// Определения констант для типов курсоров (на случай если они не определены)
#ifndef OCR_NORMAL
#define OCR_NORMAL          32512
#define OCR_IBEAM           32513
#define OCR_WAIT            32514
#define OCR_CROSS           32515
#define OCR_UP              32516
#define OCR_SIZENWSE        32642
#define OCR_SIZENESW        32643
#define OCR_SIZEWE          32644
#define OCR_SIZENS          32645
#define OCR_SIZEALL         32646
#define OCR_NO              32648
#define OCR_HAND            32649
#define OCR_APPSTARTING     32650
#endif

// ========== ДАННЫЕ ОБМАННОГО КУРСОРА ==========
// Большая белая стрелка Windows 64x64 пикселя с СМЕЩЕННЫМ HOTSPOT!
// Визуально стрелка в левом верхнем углу, но клик происходит в точке (50, 30)!

// AND маска - определяет непрозрачную область (64x64 = 4096 бит = 512 байт)
// 0 = непрозрачно (курсор), 1 = прозрачно (фон)
static const unsigned char cursorAND[512] = {
    // Большая стрелка в левом верхнем углу (примерно 30x30 пикселей)
    0xFC,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  // 0:  ██......
    0xF8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  // 1:  ███.....
    0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  // 2:  ████....
    0xE0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  // 3:  █████...
    0xC0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  // 4:  ██████..
    0x80,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  // 5:  ███████.
    0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  // 6:  ████████
    0x00,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  // 7:  █████████
    0x00,0xFC,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  // 8:  ██████████
    0x00,0xF8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  // 9:  ███████████
    0x00,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  // 10: ████████████
    0x00,0xE0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  // 11: █████████████
    0x00,0xC0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  // 12: ██████████████
    0x00,0x80,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  // 13: ███████████████
    0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  // 14: ████████████████
    0x00,0x00,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,  // 15: █████████████████
    0x00,0x00,0xFC,0xFF,0xFF,0xFF,0xFF,0xFF,  // 16: ██████████████████
    0x00,0x00,0xF8,0xFF,0xFF,0xFF,0xFF,0xFF,  // 17: ███████████████████
    0x00,0x00,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,  // 18: ████████████████████
    0x00,0x00,0xE0,0xFF,0xFF,0xFF,0xFF,0xFF,  // 19: █████████████████████
    0x00,0x00,0xC0,0xFF,0xFF,0xFF,0xFF,0xFF,  // 20: ██████████████████████
    0x00,0x00,0x80,0xFF,0xFF,0xFF,0xFF,0xFF,  // 21: ███████████████████████
    0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,  // 22: ████████████████████████
    0x00,0x00,0x00,0xFE,0xFF,0xFF,0xFF,0xFF,  // 23: █████████████████████████
    0x00,0x00,0x00,0xFC,0xFF,0xFF,0xFF,0xFF,  // 24: ██████████████████████████
    0x00,0x00,0x00,0xF8,0xFF,0xFF,0xFF,0xFF,  // 25: ███████████████████████████
    0x00,0xF8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  // 26: ███████████ (хвост стрелки)
    0x80,0xFC,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  // 27: ███████░██
    0xC0,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  // 28: ██████░░███
    0xE0,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  // 29: █████░░░███
    0xF0,0xF8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  // 30: ████░░░█████
    0xF8,0xF8,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  // 31: ███░░░██████
    0xFC,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  // 32: ██░░░███████
    0xFF,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  // 33: ░░░░████████
    0xFF,0xE0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  // 34: ░░░█████████
    0xFF,0xC0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,  // 35: ░░██████████
    // Остальное прозрачно
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF
};

// XOR маска - определяет цвет (64x64 = 4096 бит = 512 байт)
// Там где AND=0: XOR=0 даст черный, XOR=1 даст белый
static const unsigned char cursorXOR[512] = {
    // Белая стрелка с черной обводкой
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 0:  контур (черный)
    0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 1:  █.█
    0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 2:  █..█
    0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 3:  █...█
    0x1E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 4:  █....█
    0x3E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 5:  █.....█
    0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 6:  █......█
    0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 7:  █.......█
    0xFE,0x01,0x00,0x00,0x00,0x00,0x00,0x00,  // 8:  █........█
    0xFE,0x03,0x00,0x00,0x00,0x00,0x00,0x00,  // 9:  █.........█
    0xFE,0x07,0x00,0x00,0x00,0x00,0x00,0x00,  // 10: █..........█
    0xFE,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,  // 11: █...........█
    0xFE,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,  // 12: █............█
    0xFE,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,  // 13: █.............█
    0xFE,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,  // 14: █..............█
    0xFE,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,  // 15: █...............█
    0xFE,0xFF,0x01,0x00,0x00,0x00,0x00,0x00,  // 16: █................█
    0xFE,0xFF,0x03,0x00,0x00,0x00,0x00,0x00,  // 17: █.................█
    0xFE,0xFF,0x07,0x00,0x00,0x00,0x00,0x00,  // 18: █..................█
    0xFE,0xFF,0x0F,0x00,0x00,0x00,0x00,0x00,  // 19: █...................█
    0xFE,0xFF,0x1F,0x00,0x00,0x00,0x00,0x00,  // 20: █....................█
    0xFE,0xFF,0x3F,0x00,0x00,0x00,0x00,0x00,  // 21: █.....................█
    0xFE,0xFF,0x7F,0x00,0x00,0x00,0x00,0x00,  // 22: █......................█
    0xFE,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,  // 23: █.......................█
    0xFE,0xFF,0xFF,0x01,0x00,0x00,0x00,0x00,  // 24: █........................█
    0xFE,0xFF,0xFF,0x03,0x00,0x00,0x00,0x00,  // 25: █.........................█
    0xFE,0x03,0x00,0x00,0x00,0x00,0x00,0x00,  // 26: █.........█ (хвост)
    0x3E,0x01,0x00,0x00,0x00,0x00,0x00,0x00,  // 27: █.......█.█
    0x1E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 28: █......█..█
    0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 29: █.....█...█
    0x06,0x03,0x00,0x00,0x00,0x00,0x00,0x00,  // 30: █....█.....█
    0x02,0x03,0x00,0x00,0x00,0x00,0x00,0x00,  // 31: █...█......█
    0x00,0x07,0x00,0x00,0x00,0x00,0x00,0x00,  // 32: █..█.......█
    0x00,0x07,0x00,0x00,0x00,0x00,0x00,0x00,  // 33: контур
    0x00,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,  // 34: контур
    0x00,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,  // 35: контур (черный)
    // Остальное прозрачно
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

// Функция создания ОБМАННОГО курсора со смещенным hotspot
HCURSOR CreateBigCustomCursor() {
    // CreateCursor создает курсор из битовых масок AND и XOR
    // ВАЖНО: Hotspot смещен относительно визуального изображения стрелки!
    // Визуально стрелка в позиции (0,0), но клик происходит в точке (50,30)
    // Курсор теперь 64x64, чтобы hotspot поместился внутри границ!
    // Это создает эффект обмана - пользователь промахивается мимо целей!
    return CreateCursor(
        NULL,           // hInstance (NULL для не-ресурсных курсоров)
        50,             // xHotSpot - СМЕЩЕН на 50 пикселей вправо от визуального кончика!
        30,             // yHotSpot - СМЕЩЕН на 30 пикселей вниз от визуального кончика!
        64,             // Ширина курсора (увеличен, чтобы hotspot поместился)
        64,             // Высота курсора (увеличен, чтобы hotspot поместился)
        cursorAND,      // AND маска (прозрачность)
        cursorXOR       // XOR маска (цвет - ЯРКИЙ!)
    );
}

// Точка входа WinMain гарантирует отсутствие консольного окна
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
    // 1. Жёсткий пинок системе через спец. флаг 0x2029 (Гарантия работы на Win 10/11)
    // ВАЖНО: Эта функция ожидает размер в ПИКСЕЛЯХ, а не индекс 1-15.
    // 15 пикселей = очень маленький курсор.
    // 256 пикселей = огромный курсор (соответствует максимуму).
    // Вы просили 5 пикселей (очень маленький). Если нужно большой - верните 256.
    // Используем 0x2029 напрямую, так как это недокументированный флаг.
    SystemParametersInfoA(0x2029, 0, (PVOID)300, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);

    // 2. Устанавливаем максимальную скорость мыши (20)
    // SPI_SETMOUSESPEED = 0x0071. Диапазон 1-20.
    // Используем стандартную константу или 0x0071.
    SystemParametersInfoA(SPI_SETMOUSESPEED, 0, (PVOID)20, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);

    // 3. Включаем след курсора (Mouse Trails)
    // SPI_SETMOUSETRAILS = 0x005D. uiParam = длина следа (2-7). 
    // Значение 100 игнорируется системой. Ставим официальный максимум = 7.
    SystemParametersInfoA(SPI_SETMOUSETRAILS, 7, 0, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);

    // Дополнительно пишем в реестр, так как иногда SPI_SETMOUSETRAILS без этого не срабатывает
    HKEY hMouseKey;
    if (RegCreateKeyExA(HKEY_CURRENT_USER, "Control Panel\\Mouse", 0, NULL, REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &hMouseKey, NULL) == ERROR_SUCCESS) {
        const char* trails = "7";
        RegSetValueExA(hMouseKey, "MouseTrails", 0, REG_SZ, (const BYTE*)trails, 2);
        RegCloseKey(hMouseKey);
    }

    // 4. На всякий случай обновляем обычные курсоры тоже (для надежности)
    // SPI_SETCURSORS = 0x0057.
    SystemParametersInfoA(SPI_SETCURSORS, 0, NULL, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);

    // ========== ЗАМЕНА КУРСОРА НА КАСТОМНЫЙ ==========
    // Создаем большой кастомный курсор из встроенных данных
    HCURSOR customCursor = CreateBigCustomCursor();
    
    if (customCursor) {
        // Заменяем ВСЕ типы системных курсоров на наш кастомный
        // CopyCursor нужен потому что SetSystemCursor забирает ownership
        SetSystemCursor(CopyCursor(customCursor), OCR_NORMAL);      // Обычная стрелка
        SetSystemCursor(CopyCursor(customCursor), OCR_IBEAM);       // Текстовый I-beam
        SetSystemCursor(CopyCursor(customCursor), OCR_WAIT);        // Часы/ожидание
        SetSystemCursor(CopyCursor(customCursor), OCR_CROSS);       // Крестик (точное выделение)
        SetSystemCursor(CopyCursor(customCursor), OCR_UP);          // Стрелка вверх
        SetSystemCursor(CopyCursor(customCursor), OCR_SIZENWSE);    // Изменение размера ↖↘
        SetSystemCursor(CopyCursor(customCursor), OCR_SIZENESW);    // Изменение размера ↗↙
        SetSystemCursor(CopyCursor(customCursor), OCR_SIZEWE);      // Изменение размера ↔
        SetSystemCursor(CopyCursor(customCursor), OCR_SIZENS);      // Изменение размера ↕
        SetSystemCursor(CopyCursor(customCursor), OCR_SIZEALL);     // Перемещение (4 стрелки)
        SetSystemCursor(CopyCursor(customCursor), OCR_NO);          // Запрещено (перечеркнутый круг)
        SetSystemCursor(CopyCursor(customCursor), OCR_HAND);        // Рука (ссылки)
        SetSystemCursor(CopyCursor(customCursor), OCR_APPSTARTING); // Фоновая работа
        
        // Уничтожаем оригинальный хэндл (копии уже созданы)
        DestroyCursor(customCursor);
    }

    // ========== ПРОГРАММНОЕ УМНОЖЕНИЕ СКОРОСТИ КУРСОРА ==========
    // Настройки
    double multiplier = 4.0;  // Изменяемый коэффициент ускорения (можно менять на 1.5, 3.0, и т.д.)
    
    // Переменные для отслеживания позиции курсора
    POINT prevPos, currentPos;
    GetCursorPos(&prevPos);  // Получаем начальную позицию
    
    // Основной цикл программного ускорения
    while (true) {
        // Kill Switch: нажатие F9 для экстренного выхода
        if (GetAsyncKeyState(VK_F9) & 0x8000) {
            break;  // Выход из цикла
        }
        
        // Получить текущую позицию курсора
        GetCursorPos(&currentPos);
        
        // Вычислить смещение (дельту) от предыдущей позиции
        int deltaX = currentPos.x - prevPos.x;
        int deltaY = currentPos.y - prevPos.y;
        
        // Вычисляем абсолютное значение смещения
        int absDeltaX = (deltaX >= 0) ? deltaX : -deltaX;
        int absDeltaY = (deltaY >= 0) ? deltaY : -deltaY;
        
        // Проверка 1: Игнорируем очень маленькие движения (шум сенсора, дрожание)
        // Проверка 2: Игнорируем аномально большие смещения (защита от прыжков между экранами)
        if ((absDeltaX > 1 || absDeltaY > 1) && absDeltaX < 300 && absDeltaY < 300) {
            // Применить умножение к смещению
            // Новая позиция = старая позиция + (смещение * множитель)
            int newX = prevPos.x + (int)(deltaX * multiplier);
            int newY = prevPos.y + (int)(deltaY * multiplier);
            
            // Установить новую позицию курсора
            SetCursorPos(newX, newY);
            
            // ВАЖНО: Обновляем prevPos на ту позицию, которую мы установили
            // Это предотвращает накопление ошибок и создание обратной связи
            prevPos.x = newX;
            prevPos.y = newY;
        } else {
            // Если движение слишком маленькое или слишком большое - просто обновляем prevPos
            // без применения ускорения (предотвращает бесконечные прыжки)
            prevPos = currentPos;
        }
        
        // Задержка для снижения нагрузки на CPU
        Sleep(5);  // 5 мс - баланс между плавностью и нагрузкой
    }

    return 0;
}